<!-- 主观层面：踏实、写代码靠谱、爱学东西
技术层面：js基础扎实一些（别es6一点不会写，数组的map、reduce都没用过），react或vue至少有一个能熟练使用（比如react知道hook是什么，知道生命周期有哪些，干什么用的），懂点webpack（知道单入口多入口是什么意思，知道怎么能搞出按需加载的模块）、稍微有点算法基础（至少得能手写冒泡排序和obj递归copy），web安全（知道xss可以在react里有现成的接口组件可以用）
会用git，知道怎么拉分支，怎么解冲突。
得如果候选人如果现在薪资比较低，但能力很强、非常有潜力，只要面试给到D6+，在这个职级上可谈的范围就会大一些 -->
<!-- 1.js基础扎实
2.熟练使用vue，知道生命周期，hooks
3.了解webpack  知道单入口，多入口，知道怎么搞出按需加载的模块
4.手写冒泡排序和obj递归copy
5.web安全 xss攻击
6.git拉分支，解决冲突 -->

beforeCreated(创建前)在数据观测和初始化事件还未开始
created(创建后)完成数据观测、属性和方法的运算，初始化事件，$el属性还没有显示出来
beforeMounted(挂载前)在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：模板编译。把data里面的数据和模板生成html。此时还有没有挂载html到页面上
mounted（挂载后）在el被新创建的vm.$el替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。
beforeUpdate(更新前)在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步更改状态，不会触发附加的重渲染过程。
update(更新后)在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件的DOM已经更新，所以可以执行依赖于DOM的操作，然而在大多数情况下应该避免此期间更改状态，因为这可能会导致更新无限循环。改钩子在服务器渲染期间不能被调用
beforeDestory(销毁前) 在实例销毁之前调用。实例仍然完全可用
destory在实例销毁之后调用。调用后，所有的时间监听器会被移除，所有的子实例也会被销毁。该钩子在服务器渲染期间不能被调用。

webpack的整个生命周期
webpack的运行流程是一个串行的过程，从启动到结束会一次执行以下流程
初始化参数 从配置文件和Shell语句中读取与合并参数，得出最终参数
开始编译 用上一步得到的参数初始化Compiler对象，加载所有配置的插件，执行对象的run方法开始执行编译
确定入口 根据配置中的entry 找出所有文件的入口文件
编译模板 
完成模板编译
输出资源
输出完成

多入口打包
基本思路就是每个页面对应一个entry，一个html-webpack-plugin，但是这样的缺点就是每次新增和删除页面需要更改webpack配置


vue原理
双向绑定
模板编译
diff算法
vue数据驱动原理的理解
vue通过Object.defineProperty侦测数据对象的getter setter
虚拟Dom是在DOM的基础上建立了一个抽象层，对数据和状态所做的任何改动。都会被自动同步到虚拟Dom，最后再批量同步到DOM中

 
vue
template 编译 render function  Vnode  虚拟DOM

react

jsx render function  Vnode 虚拟DOM
